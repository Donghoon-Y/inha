function dx = attitude_mode_switch(t, x, J, Kp, Kd, tau_max, r_eci_sat, v_eci_sat, unit_rho_sun, r_gs_ecef, angle,dt)
     %상태변수
     q = x(1:4);
     w = x(5:7);
    
     %Normalize
     q = q/norm(q);

     C_bi = dcm_q(q);

     %시간 매칭
     k = round(t/dt) + 1;

     if k < 1, k =1; end
     if k > size(r_eci_sat, 1), k = size(r_eci_sat, 1); end
     %현재상태(m로 통일)
     r_sat = r_eci_sat(k, :).'*1000; %3*1로 맞추기
     v_sat = v_eci_sat(k, :).'*1000;
     sun_point = unit_rho_sun(k,:).'; %단위벡터

     %지상국 ECI로 변환
     We = 7.292115e-5; % [rad/s]
     theta = We * t;   % 회전각
     R_ecef2eci = [cos(theta), -sin(theta), 0;
                  sin(theta),  cos(theta), 0;
                           0,           0, 1];

     r_gs_eci = R_ecef2eci*r_gs_ecef;
     v_gs_eci = cross([0;0;We], r_gs_eci);

     %모드 변환 기준 설정
     r_rel = r_gs_eci - r_sat;

     u_zenith = r_gs_eci/norm(r_gs_eci);
     u_gs2sat = -r_rel/norm(r_rel);

     sin_elv = dot(u_gs2sat,u_zenith);
     elv = rad2deg(asin(sin_elv));
     f_dot = norm(cross(r_sat, v_sat))/norm(r_sat)^2;

     if elv >= angle
         MODE = 'GROUND' ;
     else
         MODE = 'SUN';
     end

    if strcmp(MODE, 'GROUND')
         v_rel = v_gs_eci - v_sat;
         u_vec = r_rel / norm(r_rel); % ECI 기준 목표 벡터 (지상국 방향)
         
         % 1. 목표 각속도 및 각가속도 (기존 유지)
         w_des = cross(u_vec, v_rel) / norm(r_rel);
         w_dot_des = cross(u_vec, r_sat) * (f_dot^2) / norm(r_rel) ...
                     - 2 * w_des * (dot(u_vec, v_rel) / norm(r_rel));
         
         % 2. [핵심 수정] 벡터 기반 오차 계산 (Vector-Based Error)
         % 복잡한 DCM/Quaternion 변환 대신, 물리적으로 직관적인 '외적' 사용
         
         % (1) 목표 벡터를 Body Frame으로 가져옴 (C_bi는 I->B 행렬)
         u_vec_body = C_bi * u_vec; 
         
         % (2) 내 몸의 지향 목표 축 (X축 = Antenna)
         x_b = [1; 0; 0];
         
         % (3) 오차 벡터 계산 (Cross Product Steering)
         % "내 X축(x_b)을 목표(u_vec_body)로 맞추려면 어느 축으로 돌려야 하는가?"
         % q_err_vec 방향: 회전축, 크기: sin(theta)
         q_err_vec = cross(u_vec_body, x_b); 
         
         % (4) 스칼라 값 (옵션, 180도 회전 방지용)
         % dot product가 양수면 오차 < 90도
         q_err_scalar = dot(u_vec_body, x_b) + 1; % 특이점 방지용 더미
         
         % 주의: 외적 순서에 따라 부호가 바뀜.
         % T = -Kp * q_err_vec 식을 쓰려면, q_err_vec은 "오차(Error)"여야 함.
         % 오차 = 목표 - 현재.
         % 현재(x_b)를 목표(u)로 보내려면 cross(x_b, u) 방향으로 돌려야 함.
         % 위 식은 cross(u, x_b)이므로 부호가 반대(-).
         % 따라서 제어 식 T = -Kp * q_err_vec 에서 (-)와 결합되어 (+) 토크가 됨 (정상).
         
         % 3. Feedforward를 위한 행렬 구성 (필요시 사용, 오차 계산엔 안 씀)
         % (이 부분은 오차 계산과 무관하므로 생략 가능하거나 기존 유지)

     else
         w_des = [0; 0; 0];
         w_dot_des = [0; 0; 0];
         x_b = [1; 0; 0];
         s_i = sun_point;   % 3x1
         ns = norm(s_i);
         if ns < 1e-12
          s_i = [1;0;0];               
         else
          s_i = s_i / ns;
         end

         %Sun position vector Body Frame Rotation
         C_bi = dcm_q(q);
         s_b  = C_bi * s_i;
         s_b  = s_b / norm(s_b);  

         prime_axis = cross(s_b, x_b); % 회전축
         axis_dot = dot(s_b, x_b);
         axis_dot = max(min(axis_dot, 1.0), -1.0);

         theta = acos(axis_dot);

         %회전축 Normalize
         if norm(prime_axis) < 1e-6
          q_err_scalar = 1;
          q_err_vec = [0; 0; 0];
         else 
          prime_axis = prime_axis/norm(prime_axis);
          q_err_scalar = cos(theta/2);
          q_err_vec = prime_axis * sin(theta/2);
         end 
        
         q_err = [q_err_vec; q_err_scalar];
     end

     
     w_err = w-C_bi*w_des;

     T_feedforward = J*(C_bi*w_dot_des);
     
     T_gyro = cross(w, J*w);

     sign_q4 = sign(q_err(4));
     if sign_q4 == 0, sign_q4 = 1; end

     T_req = -Kp*sign_q4*q_err_vec -Kd*w_err + T_feedforward + T_gyro;

     T = max(min(T_req, tau_max), -tau_max);

   
    % --- rigid body dynamics ---
     h  = J*w;
     dw = J\(T - cross(w, h));

    % --- quaternion kinematics ---
     dq = quatKinematics(q, w);

     dx = [dq; dw];

end